/*
 * 1 から n までの異なる自然数で構成されるサイズ n の arr が与えられます。
 * この配列のインデックスは 0 ではなく、1 から始まると仮定します。
 * i 番目に存在する要素は arr[i] に移動し、再び i 番目に戻るまで arr[arr[i]]、arr[arr[arr[i]]]… というように移動を繰り返します。
 * 配列 intArr が与えられるので、各要素 i が再び元の位置に戻るまでの必要なステップを数を返す、stepsToComeBack という関数を作成してください。
 * 
 * 例えば、[4,3,2,5,1] の 4 の動きを見てみましょう。4 は arr[4] = 5、arr[5] = 1、arr[1] = 4 へと変化し、3 ステップを必要とします。
 * また、3 は arr[3] = 2、arr[2] = 3 となり、2 ステップを必要とします。すべての要素に必要なステップ数を求めると、答えは [3,2,2,3,3] となります。
 * 
 * stepsToComeBack([1,2]) --> [1,1]
 * stepsToComeBack([3,2,1]) --> [2,1,2]
 * stepsToComeBack([1,3,4,2]) --> [1,3,3,3]
 * stepsToComeBack([2,3,5,1,4]) --> [5,5,5,5,5]
 * stepsToComeBack([5,3,2,4,1]) --> [2,2,2,1,2]
 * stepsToComeBack([5,3,8,4,1,9,7,2,6]) --> [2,3,3,1,2,2,1,3,2]
 * stepsToComeBack([63,68,98,49,50,97,13,83,18,25,51,22,59,69,36,91,12,19,84,90,11,46,31,7,16,21,23,71,78,9,52,73,79,
 * 32,81,55,10,64,61,80,87,92,95,3,8,76,20,14,40,62,94,35,65,45,85,41,4,39,37,57,53,26,74,47,38,29,89,33,66,30,17,43,
 * 28,67,6,56,96,75,60,1,99,100,24,15,54,88,72,58,2,93,44,42,48,77,86,27,70,5,34,82]) --> [15,15,81,15,81,81,81,81,81,
 * 81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,15,81,81,81,81,81,81,15,81,2,81,81,81,81,81,81,
 * 15,81,81,81,81,81,81,81,15,81,81,15,81,81,15,81,81,81,15,15,81,81,81,81,81,15,81,81,81,81,15,15,81,2,81,81,81,81,81,
 * 81,15,81,81,2,81,81,81,81,81,81,81,2]
 */
public class Problem257 {
	public static int[] stepsToComeBack(int[] inputArr){
		int[] result = new int[inputArr.length];
		int inputArrPointer = 0;
		for(int i=0; i<inputArr.length; i++){
			inputArrPointer = inputArr[i];
			while(true){
				result[i] = result[i] + 1;
				inputArrPointer = inputArr[inputArrPointer - 1];
				if(inputArrPointer == inputArr[i]) break;
			}
		}
		return result;
	}
}
