/*
 * 2分探索木からノード削除
 * 異なる整数値で構成される二分探索木（BST）の根ノード root と整数 key が与えられるので、
 * BST から key を削除する bstDelete という関数を作成してください。
 * もし key がすでに BST 内に存在しない場合は何も削除せず、根ノードをそのまま返してください。
 * ①削除したいノード（N）が葉ノードの場合、そのノードを単純に削除します。
 * ②削除したいノード（N）が左側に子ノードを持たない場合、そのノードの右側の部分木を親ノード（P）の部分木に置き換えます。
 * ③削除したいノード（N）が右側に子ノードを持たない場合、そのノードの左側の部分木を親ノード（P）の部分木に置き換えます。
 * ④削除したいノード（N）が左右に子ノードを持つ場合、少し複雑な処理が必要になります。
 * この場合、削除したいノードの後続ノード（該当ノードの値よりも大きく、それらの中で最も小さい値を持つノード）を見つけます。
 * 後続ノード（S）は、削除したいノードの右側の部分木に必ず存在します。
 * ④-1,後続ノードの親ノードを SP とします。SP が削除したいノード（N）と同じ場合、
 * つまり後続ノード（S）が削除したいノード（N）の直接の子である場合、後続ノード（S）をその親ノード（SP）に置き換えます。
 * 後続ノード（S）であり、削除したいノード（N）より大きい最小値であるため、定義通り左部分木は常に null になります。
 * ④-2,しかし、SP が削除したいノード（N）と異なる場合、つまり後続ノード（S）が削除したいノード（N）の右部分木の深部にある場合、次の処理を行います。
 * SP から後続ノード（S）を取り除き、その位置に後続ノード（S）の右部分木を移植します。その結果、後続ノード（S）は孤立し、後続ノード（S）の右部分木は元々の位置に残ります。
 * 削除したいノード（N）の位置に後続ノード（S）を移植します。その結果、後続ノード（S）が削除したいノードの親ノード（P）の新しい子ノードになります。
 * 最後に、削除したいノード（N）の左部分木を後続ノード（S）の左部分木に設定します。
 * これにより、削除したいノード（N）の左部分木が保持され、後続ノード（S）が削除したいノード（N）の全ての子を引き継ぎます。これらの操作により、二分探索木のプロパティが維持されます。
 */
public class Problem215 {
	public static BinaryTree<Integer> bstDelete(BinaryTree<Integer> root, int key) {
		// 削除対象のノードが見つからない場合
		if (root == null) return null;

		if (key < root.data) {
			// 削除対象のキーが現在のノードのキーより小さい場合、左の子ノードに進む
			root.left = bstDelete(root.left, key);
		} else if (key > root.data) {
			// 削除対象のキーが現在のノードのキーより大きい場合、右の子ノードに進む
			root.right = bstDelete(root.right, key);
		} else {
			// 削除対象のノードが見つかった場合

			// 一つの子もしくは子がない場合
			if (root.left == null) return root.right;
			if (root.right == null) return root.left;

			// 二つの子を持つノードの場合、右部分木で最も小さいノード（後継者）を見つける
			root.data = findMin(root.right);

			// 後継者のノードを削除
			root.right = bstDelete(root.right, root.data);
		}

		// 更新されたルートノードを返す
		return root;
	}

	private static int findMin(BinaryTree<Integer> node) {
		int min = node.data;
		while (node.left != null) {
			min = node.left.data;
			node = node.left;
		}
		return min;
	}
}
